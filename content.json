{"meta":{"title":"雪海的技术小窝","subtitle":"雪海觅隐香","description":"路尽隐香处，翩然雪海间，梅花仍犹在，雪海何处寻！","author":"CodingStartlet","url":"https://www.codingstarlet.cn","root":"/"},"pages":[],"posts":[{"title":"MySQL事务锁等待超时 Lock wait timeout exceeded; try restarting transaction","slug":"mysql-lock-wait-timeout-exceeded","date":"2021-01-12T04:17:37.000Z","updated":"2021-01-12T04:22:45.328Z","comments":true,"path":"articles/null.html","link":"","permalink":"https://www.codingstarlet.cn/articles/null.html","excerpt":"","text":"工作中处理定时任务分发消息时出现的问题，在查找并解决问题的时候，将相关的问题博客收集整理，在此记录下，以便之后再遇到相同的问题，方便查阅。 问题场景问题出现的场景： 在消息队列处理消息时，同一事务内先后对同一条数据进行了插入和更新操作; 多台服务器操作同一数据库； 瞬时出现高并发现象； 导致数据更新或新增后数据经常自动回滚；表操作总报 Lock wait timeout exceeded 并长时间无反应 问题剖析原因分析MySql Lock wait timeout exceeded 这个问题我相信大家对它并不陌生，但是有很多人对它产生的原因以及处理吃的不是特别透，很多情况都是交给DBA去定位和处理问题，接下来我们就针对这个问题来展开讨论： Mysql造成锁的情况有很多，下面我们就列举一些情况： 执行DML操作没有commit，再执行删除操作就会锁表。 在同一事务内先后对同一条数据进行插入和更新操作。 表索引设计不当，导致数据库出现死锁。 长事务，阻塞DDL，继而阻塞所有同表的后续操作。 但是要区分的是Lock wait timeout exceeded与Dead Lock是不一样。 Lock wait timeout exceeded：后提交的事务等待前面处理的事务释放锁，但是在等待的时候超过了mysql的锁等待时间，就会引发这个异常。 Dead Lock：两个事务互相等待对方释放相同资源的锁，从而造成的死循环，就会引发这个异常。 还有一个要注意的是innodb_lock_wait_timeout与lock_wait_timeout也是不一样的。 innodb_lock_wait_timeout：innodb的dml操作的行级锁的等待时间 lock_wait_timeout：数据结构ddl操作的锁的等待时间 那么如何查看innodb_lock_wait_timeout的具体值： 1SHOW VARIABLES LIKE &#x27;innodb_lock_wait_timeout&#x27; 如何修改innode lock wait timeout的值，参数修改的范围有Session和Global，并且支持动态修改，可以有两种方法修改： 方法一： 通过下面语句修改 12set innodb_lock_wait_timeout=100;set global innodb_lock_wait_timeout=100; ps. 注意global的修改对当前线程是不生效的，只有建立新的连接才生效。 方法二： 修改参数文件/etc/my.cnf innodb_lock_wait_timeout = 50 ps. innodb_lock_wait_timeout指的是事务等待获取资源等待的最长时间，超过这个时间还未分配到资源则会返回应用失败； 当锁等待超过设置时间的时候，就会报如下的错误；ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction。其参数的时间单位是秒，最小可设置为1s(一般不会设置得这么小)，最大可设置1073741824秒，默认安装时这个值是50s(默认参数设置)。 原因总结 在高并发的情况下，Spring事物造成数据库死锁，后续操作超时抛出异常。 Mysql数据库采用InnoDB模式，默认参数:innodb_lock_wait_timeout设置锁等待的时间是50s，一旦数据库锁超过这个时间就会报错。 解决方法 应急方法：show full processlist; kill掉出现问题的进程。 ps.有的时候通过processlist是看不出哪里有锁等待的，当两个事务都在commit阶段是无法体现在processlist上 根治方法：select * from information_schema.innodb_trx;查看有是哪些事务占据了表资源。 ps.通过这个办法就需要对innodb有一些了解才好处理 增加锁等待时间，即增大下面配置项参数值，单位为秒（s） innodb_lock_wait_timeout=500 优化存储过程,事务避免过长时间的等待 说起来很简单找到它杀掉它就搞定了，但是实际上并没有想象的这么简单，当问题出现要分析问题的原因，通过原因定位业务代码可能某些地方实现的有问题，从而来避免今后遇到同样的问题。 扩展资料参考信息 锁等待超时。是当前事务在等待其它事务释放锁资源造成的。可以找出锁资源竞争的表和语句，优化SQL，创建索引等。如果还是不行，可以适当减少并发线程数。 事务在等待给某个表加锁时超时，估计是表正被另的进程锁住一直没有释放。可以用 SHOW INNODB STATUS/G; 看一下锁的情况。 搜索解决之道，在管理节点的[ndbd default]区加：TransactionDeadLockDetectionTimeOut=10000（设置 为10秒）默认是1200（1.2秒） InnoDB会自动的检测死锁进行回滚，或者终止死锁的情况。 InnoDB automatically detects transaction deadlocks and rolls back a transaction or transactions to break the deadlock. InnoDB tries to pick small transactions to roll back, where the size of a transaction is determined by the number of rows inserted, updated, or deleted. 如果参数innodb_table_locks=1并且autocommit=0时，InnoDB会留意表的死锁，和MySQL层面的行级锁。另外，InnoDB不会检测MySQL的Lock Tables命令和其他存储引擎死锁。你应该设置innodb_lock_wait_timeout来解决这种情况。innodb_lock_wait_timeout是Innodb放弃行级锁的超时时间。 Innodb_* 表的解释Mysql的InnoDB存储引擎是支持事务的，事务开启后没有被主动Commit。导致该资源被长期占用，其他事务在抢占该资源时，因上一个事务的锁而导致抢占失败！因此出现 Lock wait timeout exceeded 下面几张表是innodb的事务和锁的信息表，理解这些表就能很好的定位问题。 innodb_trx ## 当前运行的所有事务 innodb_locks ## 当前出现的锁 innodb_lock_waits ## 锁等待的对应关系 下面对 innodb_trx 表的每个字段进行解释： 12345678910111213141516171819202122trx_id：事务ID。trx_state：事务状态，有以下几种状态：RUNNING、LOCK WAIT、ROLLING BACK 和 COMMITTING。trx_started：事务开始时间。trx_requested_lock_id：事务当前正在等待锁的标识，可以和 INNODB_LOCKS 表 JOIN 以得到更多详细信息。trx_wait_started：事务开始等待的时间。trx_weight：事务的权重。trx_mysql_thread_id：事务线程 ID，可以和 PROCESSLIST 表 JOIN。trx_query：事务正在执行的 SQL 语句。trx_operation_state：事务当前操作状态。trx_tables_in_use：当前事务执行的 SQL 中使用的表的个数。trx_tables_locked：当前执行 SQL 的行锁数量。trx_lock_structs：事务保留的锁数量。trx_lock_memory_bytes：事务锁住的内存大小，单位为 BYTES。trx_rows_locked：事务锁住的记录数。包含标记为 DELETED，并且已经保存到磁盘但对事务不可见的行。trx_rows_modified：事务更改的行数。trx_concurrency_tickets：事务并发票数。trx_isolation_level：当前事务的隔离级别。trx_unique_checks：是否打开唯一性检查的标识。trx_foreign_key_checks：是否打开外键检查的标识。trx_last_foreign_key_error：最后一次的外键错误信息。trx_adaptive_hash_latched：自适应散列索引是否被当前事务锁住的标识。trx_adaptive_hash_timeout：是否立刻放弃为自适应散列索引搜索 LATCH 的标识。 下面对 innodb_locks 表的每个字段进行解释： 12345678910lock_id：锁 ID。lock_trx_id：拥有锁的事务 ID。可以和 INNODB_TRX 表 JOIN 得到事务的详细信息。lock_mode：锁的模式。有如下锁类型：行级锁包括：S、X、IS、IX，分别代表：共享锁、排它锁、意向共享锁、意向排它锁。表级锁包括：S_GAP、X_GAP、IS_GAP、IX_GAP 和 AUTO_INC，分别代表共享间隙锁、排它间隙锁、意向共享间隙锁、意向排它间隙锁和自动递增锁。lock_type：锁的类型。RECORD 代表行级锁，TABLE 代表表级锁。lock_table：被锁定的或者包含锁定记录的表的名称。lock_index：当 LOCK_TYPE&#x3D;’RECORD’ 时，表示索引的名称；否则为 NULL。lock_space：当 LOCK_TYPE&#x3D;’RECORD’ 时，表示锁定行的表空间 ID；否则为 NULL。lock_page：当 LOCK_TYPE&#x3D;’RECORD’ 时，表示锁定行的页号；否则为 NULL。lock_rec：当 LOCK_TYPE&#x3D;’RECORD’ 时，表示一堆页面中锁定行的数量，亦即被锁定的记录号；否则为 NULL。lock_data：当 LOCK_TYPE&#x3D;’RECORD’ 时，表示锁定行的主键；否则为NULL。 下面对 innodb_lock_waits 表的每个字段进行解释： 1234requesting_trx_id：请求事务的 ID。requested_lock_id：事务所等待的锁定的 ID。可以和 INNODB_LOCKS 表 JOIN。blocking_trx_id：阻塞事务的 ID。blocking_lock_id：某一事务的锁的 ID，该事务阻塞了另一事务的运行。可以和 INNODB_LOCKS 表 JOIN。 锁等待的处理步骤 直接查看 innodb_lock_waits 表 1SELECT * FROM innodb_lock_waits; innodb_locks 表和 innodb_lock_waits 表结合： 1SELECT * FROM innodb_locks WHERE lock_trx_id IN (SELECT blocking_trx_id FROM innodb_lock_waits); innodb_locks 表 JOIN innodb_lock_waits 表: 1SELECT innodb_locks.* FROM innodb_locks JOIN innodb_lock_waits ON (innodb_locks.lock_trx_id = innodb_lock_waits.blocking_trx_id); 查询 innodb_trx 表: 1SELECT trx_id, trx_requested_lock_id, trx_mysql_thread_id, trx_query FROM innodb_trx WHERE trx_state = &#x27;LOCK WAIT&#x27;; trx_mysql_thread_id 即kill掉事务线程 ID 12SHOW ENGINE INNODB STATUS ;SHOW PROCESSLIST ; 从上述方法中得到了相关信息，我们可以得到发生锁等待的线程 ID，然后将其 KILL 掉。 KILL 掉发生锁等待的线程。 1kill ID;","categories":[{"name":"实战随笔","slug":"实战随笔","permalink":"https://www.codingstarlet.cn/categories/%E5%AE%9E%E6%88%98%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.codingstarlet.cn/tags/MySQL/"}]},{"title":"Hexo + Github 博客搭建详细教程","slug":"hexo-github-valantis","date":"2020-08-16T15:01:59.890Z","updated":"2020-11-12T16:22:30.940Z","comments":true,"path":"articles/hexo-github-valantis.html","link":"","permalink":"https://www.codingstarlet.cn/articles/hexo-github-valantis.html","excerpt":"","text":"前置环境安装 Node.js首先下载 Node.js,直接在官网下载安装包，有稳定版和最新版两个版本可供下载，安装选项全部默认，一路 Next 就可以了。 最后，安装完毕后，通过 node -v 和 npm -v 检查下版本号。 当然，如果你跟我一样比较懒，可以使用包管理器进行安装，参考 NodeJs 包管理，因为我是 macOS 系统，使用 Homebrew 进行安装 brew install node。如果对 Homebrew 不太了解的，可以看下 Mac 软件包管理器Homebrew使用指北。 123brew install nodenode -vnpm -v 添加国内镜像源为了提高 npm 运行速度需要添加淘宝源： 1npm config set registry https://registry.npm.taobao.org 安装 Git为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git 下载地址 Git 对于咱们开发人员是很常用的工具，这里就不过多阐述了。 GitHub 仓库接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。 打开https://github.com/，新建一个项目，如下所示： 然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。**名称一定要和你的github名字完全一样，比如你github名字叫abc，那么仓库名字一定要是abc.github.io**。 建议还是选默认的 Public，我试了 Private，GitHub Pages 服务竟然是要收费。项目建成后，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，会变成下面这样： 点击那个链接，就会出现自己的网页啦，效果如下： Hexo 安装Hexo 安装参考官方文档即可：Hexo 官方文档 安装完成后，输入 hexo -v 验证是否安装成功。 然后就可以初始化我们的博客，输入hexo init初始化文件夹，接着输入 npm install 安装必备的组件。 这样本地的博客配置就可以了，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开 http://localhost:4000/，就可以看到生成的博客啦！ 因为我打算使用 Volantis 主题，官方为 Mac 用户贴心准备了脚本完成全部流程（博客初始化+主题安装），所以这里我就偷个懒，直接采用脚本完成下载安装，如果你也是 Mac 用户，直接在要存放博客的文件地址下输入 curl -s https://volantis.js.org/start | bash即可安装完成。详情参考 Volantis 官网文档。 本地博客效果图如下： 将 hexo 与 github 关联起来首先打开终端，输入如下命令在 git 上注册你的 github 账户名和邮箱 123# Your github name and emailgit config --global user.name &quot;xxxx&quot;git config --global user.email &quot;xxxx@163.com&quot; Github 的用户名和邮箱自填。 然后生成秘钥 SSH Key： 12# Your github emailssh-keygen -t rsa -C &quot;xxxx@163.com&quot; 打开 GitHub，进入 settings页面，再点击 SSH and GPG keys，新建一个 SSH，名字随意，终端输入 cat ~/.ssh/id_rsa.put 将输入的内容复制到文本框，然后确定保存。 输入 ssh -T git@github.com，如下图所示，即配置成功。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repository: https://github.com/godweiyang/godweiyang.github.io branch: master repository 修改为你自己的 github 项目地址。接着需要先安装 deploy-git，也就是部署的命令，这样你才能用命令部署到 GitHub。接着 hexo clean 清除了你之前生成的东西，也可以不加。 hexo g 顾名思义，生成静态文章是 hexo generate 的缩写 hexo deploy 部署文章，可以用 hexo d 缩写： 12$ npm install hexo-deployer-git --save$ hexo clean | hexo g | hexo d 备份博客源文件博客源文件最好在远端备份一份，避免更换电脑后源文件丢失的尴尬。这里我选择将本地博客源文件上传至 github 保存，首先在 github 上新建一个仓库： 在本地博客地址执行： 123456git init-- 这里替换为你的仓库地址git remote add origin git@github.com:ChristopherChan36/blog-post.gitgit add .git commit -m &#x27;init blog post&#x27;git push origin master -u","categories":[{"name":"blog","slug":"blog","permalink":"https://www.codingstarlet.cn/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.codingstarlet.cn/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-15T03:14:46.986Z","updated":"2020-11-12T16:17:26.832Z","comments":true,"path":"articles/hello-world.html","link":"","permalink":"https://www.codingstarlet.cn/articles/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"实战随笔","slug":"实战随笔","permalink":"https://www.codingstarlet.cn/categories/%E5%AE%9E%E6%88%98%E9%9A%8F%E7%AC%94/"},{"name":"blog","slug":"blog","permalink":"https://www.codingstarlet.cn/categories/blog/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.codingstarlet.cn/tags/MySQL/"},{"name":"hexo","slug":"hexo","permalink":"https://www.codingstarlet.cn/tags/hexo/"}]}